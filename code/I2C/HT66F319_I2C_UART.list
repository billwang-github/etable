				;file D:\WORK\Project\Github\etable\code\I2C\HT66F319_I2C_UART.c
				;1	/*	Panel with 3 digits 7-segment, 6 function key, EEPROM R/W with UART interfac
				;2	**	Written by Bill Wang@GMT 2018/10/23
				;3	*/
				;4	//#include "HT66F319.h"
				;5	//#include "HT66F318.h"
				;6	#include "my_func.h"
				;7	
				;8	#define BUFF_LEN 16 
				;9	
				;10	//#define TX 	_pc3
				;11	//#define RX 	_pc4
				;12	
				;13	#define SA 	_pb0
				;14	#define SB 	_pb1
				;15	#define SC 	_pb2
				;16	#define SD 	_pc3
				;17	#define SE 	_pc4
				;18	#define SF 	_pa4
				;19	#define SG 	_pa5
				;20	#define DOT _pa6
				;21	#define C1 	_pa7
				;22	#define C2	_pb3
				;23	#define C3	_pb4
				;24	
				;25	#define KS1	_pc0
				;26	#define KS2	_pc1
				;27	#define KS3	_pc2 
				;28	#define KS4	_pa1
				;29	#define KS5	_pa3
				;30	#define KS6	_pb6
				;31	#define KS7	_pb5
				;32	
				;33	#define BUZZER _pa6
				;34	
				;35	#define SDA _pc5
				;36	#define SCL _pc6
				;37	#define I2C_DATA _iicd
				;38	#define I2C_ADDR (0x38 << 1)
				;39	#define I2C_ADDR_MATCH _iichaas
				;40	#define I2C_BUSY _iichbb
				;41	#define I2C_READ _iicsrw
				;42	#define I2C_TIMEOUT _i2ctof
				;43	#define I2C_INT_FLAG _iicf
				;44	#define I2C_TRANSMITTER _iichtx
				;45	#define I2C_TX_NOACK _iictxak
				;46	#define I2C_RX_NOACK _iicrxak
				;47	#define I2C_TIMEOUT_EN _i2ctoen
				;48	
				;49	
				;50	#define WDT_SET(x) (x == ON)? (_wdtc = 0b01010111): (_wdtc = 0b10101111) //wdtc on off
				;51	
				;52	const uint8_t seg_7_table[16] ={0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F, 0x77, 0x7C, 0x39, 0x5E, 0x79, 0x71};
				;53	const char date_code[9] ="18120700";
				;54	
				;55	volatile uint8_t com =0x01;
				;56	volatile uint16_t led_period = 900, led_duty = 900;//1sec=1953
0494	0384	addm    a, BP
0495	0384	addm    a, BP
0496	0001	clr     wdt
0497	0000	nop
0498	0030	dc	00030H
0499	008D	mov     INTEG, a
049A	0000	nop
				L049B:
049B	5F71	clr     num
049C	5F72	clr     n
049D	0F10	mov     a, 10H
049E	40F4	mov     i[1], a
				L049F:
049F	340A	clr     C
04A0	5AED	rlc     level
04A1	5AEE	rlc     addr
04A2	5AF1	rlc     num
04A3	5AF2	rlc     n
04A4	4771	mov     a, num
04A5	426F	sub     a, addr
04A6	4772	mov     a, n
04A7	5270	sbc     a, buff
04A8	380A	snz     C
04A9	2CAF	jmp     L04AF
04AA	40F2	mov     n, a
04AB	4771	mov     a, num
04AC	426F	sub     a, addr
04AD	40F1	mov     num, a
04AE	54ED	inc     level
				L04AF:
04AF	57F4	sdz     i[1]
04B0	2C9F	jmp     L049F
04B1	7873	snz     i.0
04B2	2CB8	jmp     L04B8
04B3	41F1	cpl     num
04B4	41F2	cpl     n
04B5	54F1	inc     num
04B6	3D0A	sz      Z
04B7	54F2	inc     n
				L04B8:
04B8	78F3	snz     i.1
04B9	2CBF	jmp     L04BF
04BA	41ED	cpl     level
04BB	41EE	cpl     addr
04BC	54ED	inc     level
04BD	3D0A	sz      Z
04BE	54EE	inc     addr
				L04BF:
04BF	0003	ret
04C0	1483	inc     MP1
				L04C1:
04C1	3F81	sz      MP0.7
04C2	2CC7	jmp     L04C7
04C3	0701	mov     a, MP0
04C4	0084	mov     BP, a
04C5	0702	mov     a, __iar1[0]
04C6	0003	ret
				L04C7:
04C7	1B01	rrca    MP0
04C8	0E3F	and     a, 3FH
04C9	0089	mov     TBHP, a
04CA	1B03	rrca    MP1
04CB	0087	mov     TBLP, a
04CC	1D05	tabrd   ACC
04CD	3C0A	sz      C
04CE	0708	mov     a, TBLH
04CF	0003	ret
				L0E4F:
				org	0e4fh
0E4F	0000	nop
				;57	
				;58	uint16_t height = 000;
				;59	uint8_t height_str[3] = "FFF"; // height_str[2]:MSB
				;60	
				;61	uint8_t key_stat = 0;
				;62	
				;63	uint8_t buff_i2c_rx[BUFF_LEN], buff_i2c_tx[BUFF_LEN + 3], buff_test[8];
				;64	volatile uint8_t ptr_i2c_rx_buff = 0, ptr_i2c_tx_buff = 0; // number of the received data	
				;65	
				;66	bit b_ee_data_ready = 0;
				;67	
				;68	void Init_System(void);
				;69	void Init_Vars(void);
				;70	
				;71	void Led_Current_Set(uint8_t level);
				;72	void Digit_Set(uint8_t led);
				;73	void Com_Sel(uint8_t sel);
				;74	void Led_scan(void);
				;75	
				;76	uint8_t Key_Scan(void);
				;77	void Clear_Rx(void);
				;78	
				;79	void Command_Parse(void);
				;80	
				;81	void Power_On_Reset(void);
				;82	
				;83	void main()
				;84	{	
				@code .SECTION 'CODE'
				include HT66F319.inc
0000	2830	jmp     begin_startup_value
0001	3130	set     T0POL
0002	3332	set     TM0DH.6
0003	3534	clr     TM0AH.2
0004	3736	clr     T1CK2
0005	3938	snz     TM1DL.2
0006	0000	nop
0007	3831	snz     TM0DL.0
0008	3231	set     TM0DL.4
0009	3730	clr     T0M0
000A	3030	set     T0CCLR
000B	3F00	sz      [00H].6
000C	5B06	rrca    height[0]
000D	664F	call    E4FH
000E	7D6D	sz      level.2
000F	7F07	sz      height[1].6
0010	776F	clr     addr.6
0011	397C	snz     __sledc1[42].2
0012	795E	snz     r12c.2
0013	0071	dc	00071H
				startupend3:
				@start .SECTION 'CODE'
007C	2814	jmp     _main
				;85		uint8_t  i;
				;86		volatile uint32_t temp;
				;87		
				;88		Init_Vars();
				_main:
				_main:
0014	215F	call    _Init_Vars
				;89		Init_System();			
0015	21AD	call    _Init_System
				;90	
				;91	//	buff_i2c_tx[0] = '1';
				;92	//	buff_i2c_tx[1] = '2';
				;93	//	buff_i2c_tx[2] = '3';
				;94	//	buff_i2c_tx[3] = '4';
				;95	//	buff_i2c_tx[4] = '5';
				;96	//	buff_i2c_tx[5] = '\0';
				;97	
				;98	/*==== EEPROM write test ====*/	
				;99	//	for (i = 0; i < 7; i++)
				;100	//	{
				;101	//		EE_Write_Byte(i, 0xFF);
				;102	//	}
				;103	//	
				;104	//	for (i = 0; i < 7; i++)
				;105	//	{
				;106	//		buff_i2c_tx[i] = EE_Read_Byte(i);
				;107	//	}
				;108		
				;109		EMI_ON();
0016	300E	set     EMI
				;110						
				;111		while (1)
				;112		{	
				;113			FeedWatchDog();		
				_L56:
0017	0001	clr     wdt
				;114			Command_Parse();				
0018	22E7	call    _Command_Parse
0019	2817	jmp     _L56
001A	281A	jmp     $
				@dummy .SECTION 'CODE'
001B	0000	nop
				;115														
				;116	/* wait for TX				;117	//		if ((buff_i2c_rx[0] == 0x27) && (buff_i2c_rx[1] == 0x0A) && (ptr_i2c_rx_buff == 0x0C))
				;118	//		{
				;119	//			if (buff_i2c_rx[10] != 0xA5)
				;120	//			{
				;121	//				buff_i2c_rx[0] = 0x00;
				;122	//				buff_uart_tx[0] = 'E';
				;123	//				buff_uart_tx[1] = 'R';
				;124	//				buff_uart_tx[2] = 'R';
				;125	//				buff_uart_tx[3] = '\r';
				;126	//				buff_uart_tx[4] = '\n';	
				;127	//				Uart_SendBuf(buff_uart_tx, 5 );								
				;128	//			}
				;129	//			else
				;130	//			{
				;131	//				buff_i2c_rx[0] = 0x00;
				;132	//				buff_uart_tx[0] = Hex2char(buff_i2c_rx[10] >> 4);
				;133	//				buff_uart_tx[1] = Hex2char(buff_i2c_rx[10]);
				;134	//				buff_uart_tx[2] = Hex2char(buff_i2c_rx[11] >> 4);
				;135	//				buff_uart_tx[3] = Hex2char(buff_i2c_rx[11]);
				;136	//				buff_uart_tx[4] = '\r';
				;137	//				buff_uart_tx[5] = '\n';
				;138	//				Uart_SendBuf(buff_uart_tx, 6 );	
				;139	//			}
				;140	//		}		
				;141		}
				;142	}
				;143	
				;144	void Command_Parse(void)
				;145	{
				;146		volatile uint8_t ee_addr, ee_data, i, n;
				;147		//uint16_t dlycnt;
				;148		static uint8_t u8temp = 0x00;
				;149	
				;150		if ((buff_i2c_rx[0] == 0x00) && (ptr_i2c_rx_buff >= 1)) // Read firmware version
				_Command_Parse:
				_Command_Parse:
02E7	472D	mov     a, buff_i2c_rx[0]
02E8	40FF	mov     ee_addr[1], a
02E9	50FF	sz      ee_addr[1]
02EA	2AF9	jmp     _L31
02EB	5081	sz      ptr_i2c_rx_buff[0]
02EC	2AEE	jmp     _LI7
02ED	2BF0	jmp     _L44
				;151		{
				;152			my_strcpy1(8, buff_i2c_tx, date_code);
				_LI7:
02EE	0F0E	mov     a, EH
02EF	40EF	mov     addr, a
02F0	0F80	mov     a, 80H
02F1	40F0	mov     buff, a
02F2	0F9A	mov     a, 9AH
02F3	40ED	mov     level, a
02F4	0F00	mov     a, 0H
02F5	40EE	mov     addr, a
02F6	0F08	mov     a, 8H
02F7	207D	call    _my_strcpy1
02F8	2BEE	jmp     _L53
				;153			Clear_Rx();
				;154		}	
				;155		else if ((buff_i2c_rx[0] == 0x01) && (ptr_i2c_rx_buff >= 4)) // 01: set height(string)
				_L31:
02F9	577F	sdza    ee_addr[1]
02FA	2B06	jmp     _L34
02FB	0F03	mov     a, 3H
02FC	4201	sub     a, ptr_i2c_rx_buff[0]
02FD	3C0A	sz      C
02FE	2BF0	jmp     _L44
				;156		{
				;157			height_str[2] = buff_i2c_rx[1];
02FF	472E	mov     a, buff_i2c_rx[1]
0300	4085	mov     height_str[2], a
				;158			height_str[1] = buff_i2c_rx[2];
0301	472F	mov     a, buff_i2c_rx[2]
0302	4084	mov     height_str[1], a
				;159			height_str[0] = buff_i2c_rx[3];
0303	4730	mov     a, buff_i2c_rx[3]
0304	4083	mov     height_str[0], a
0305	2BEE	jmp     _L53
				;160			Clear_Rx();
				;161		}
				;162		else if ((buff_i2c_rx[0] == 0x02) && (ptr_i2c_rx_buff >= 3)) // 02: set height(number)
				_L34:
0306	477F	mov     a, ee_addr[1]
0307	0A02	sub     a, 2H
0308	390A	snz     Z
0309	2B26	jmp     _L35
030A	0F02	mov     a, 2H
030B	4201	sub     a, ptr_i2c_rx_buff[0]
030C	3C0A	sz      C
030D	2BF0	jmp     _L44
				;163		{
				;164			height = (buff_i2c_rx[1] << 8) | buff_i2c_rx[2];
030E	472E	mov     a, buff_i2c_rx[1]
030F	40C0	mov     rc, a
0310	472F	mov     a, buff_i2c_rx[2]
0311	40BF	mov     rb, a
0312	473F	mov     a, rb
0313	4086	mov     height[0], a
0314	4740	mov     a, rc
0315	4087	mov     height[1], a
				;165			utoa(height, height_str);
0316	0F83	mov     a, 83H
0317	40F7	mov     str, a
0318	0F00	mov     a, 0H
0319	40F8	mov     str[1], a
031A	473F	mov     a, rb
031B	40F5	mov     n, a
031C	4740	mov     a, rc
031D	40F6	mov     n[1], a
031E	20A2	call    _utoa
				;166			buff_i2c_tx[0] = height_str[2];
031F	4705	mov     a, height_str[2]
0320	409A	mov     buff_i2c_tx[0], a
				;167			buff_i2c_tx[1] = height_str[1];
0321	4704	mov     a, height_str[1]
0322	409B	mov     buff_i2c_tx[1], a
				;168			buff_i2c_tx[2] = height_str[0];
0323	4703	mov     a, height_str[0]
0324	409C	mov     buff_i2c_tx[2], a
0325	2BEE	jmp     _L53
				;169			Clear_Rx();
				;170		}	
				;171		else if ((buff_i2c_rx[0] == 0x03) && (ptr_i2c_rx_buff >= 3)) // read EEPROM
				_L35:
0326	477F	mov     a, ee_addr[1]
0327	0A03	sub     a, 3H
0328	390A	snz     Z
0329	2B4D	jmp     _L37
032A	0F02	mov     a, 2H
032B	4201	sub     a, ptr_i2c_rx_buff[0]
032C	3C0A	sz      C
032D	2BF0	jmp     _L44
				;172		{
				;173			
				;174			b_ee_data_ready = 0;
032E	743D	clr     b_ee_data_ready[0].0
				;175			n = buff_i2c_rx[1];
032F	472E	mov     a, buff_i2c_rx[1]
0330	40FB	mov     n[0], a
				;176			ee_addr = buff_i2c_rx[2];	
0331	472F	mov     a, buff_i2c_rx[2]
0332	40FE	mov     ee_addr[0], a
				;177					
				;178			for (i = 0; i < n; i++)
0333	5F7C	clr     i[0]
				_L39:
0334	477C	mov     a, i[0]
0335	427B	sub     a, n[0]
0336	3C0A	sz      C
0337	2B4B	jmp     _L54
0349	54FC	inc     i[0]
034A	2B34	jmp     _L39
				;179			{
				;180				buff_i2c_tx[i] = EE_Read_Byte(i);			
0338	477C	mov     a, i[0]
0339	40FF	mov     ee_addr[1], a
033A	477C	mov     a, i[0]
033B	40BE	mov     ra, a
033C	473E	mov     a, ra
033D	2140	call    _EE_Read_Byte
033E	40BE	mov     ra, a
033F	0F9A	mov     a, 9AH
0340	437F	add     a, ee_addr[1]
0341	0083	mov     MP1, a
0342	0F00	mov     a, 0H
0343	1F01	clr     MP0
0344	1381	adcm    a, MP0
0345	0701	mov     a, MP0
0346	0084	mov     BP, a
0347	473E	mov     a, ra
0348	0082	mov     __iar1[0], a
				;181			}
				;182			b_ee_data_ready = 1;	
				_L54:
034B	703D	set     b_ee_data_ready[0].0
034C	2BEE	jmp     _L53
				;183			
				;184			Clear_Rx();			
				;185		}
				;186		else if ((buff_i2c_rx[0] == 0x04) && (ptr_i2c_rx_buff >= 3)) // write EEPROM byte
				_L37:
034D	477F	mov     a, ee_addr[1]
034E	0A04	sub     a, 4H
034F	390A	snz     Z
0350	2B60	jmp     _L32
0351	0F02	mov     a, 2H
0352	4201	sub     a, ptr_i2c_rx_buff[0]
0353	3C0A	sz      C
0354	2BF0	jmp     _L44
				;187		{	
				;188			ee_addr = buff_i2c_rx[1];
0355	472E	mov     a, buff_i2c_rx[1]
0356	40FE	mov     ee_addr[0], a
				;189			ee_data = buff_i2c_rx[2];
0357	472F	mov     a, buff_i2c_rx[2]
0358	40FD	mov     ee_data[0], a
				;190			EE_Write_Byte(ee_addr, ee_data);
0359	477E	mov     a, ee_addr[0]
035A	40BE	mov     ra, a
035B	477D	mov     a, ee_data[0]
035C	40ED	mov     level, a
035D	473E	mov     a, ra
035E	20FA	call    _EE_Write_Byte
035F	2BEE	jmp     _L53
				;191	
				;192			Clear_Rx();			
				;193		}		
				;194		else if ((buff_i2c_rx[0] == 0x05) && (ptr_i2c_rx_buff >= (buff_i2c_rx[1] + 3))) // write EEPROM bytes
				_L32:
0360	477F	mov     a, ee_addr[1]
0361	0A05	sub     a, 5H
0362	390A	snz     Z
0363	2B86	jmp     _L42
0364	472E	mov     a, buff_i2c_rx[1]
0365	40BE	mov     ra, a
0366	4701	mov     a, ptr_i2c_rx_buff[0]
0367	40C1	mov     rd, a
0368	5F42	clr     re
0369	0F03	mov     a, 3H
036A	433E	add     a, ra
036B	40BF	mov     rb, a
036C	0F00	mov     a, 0H
036D	5F40	clr     rc
036E	53C0	adcm    a, rc
036F	4741	mov     a, rd
0370	423F	sub     a, rb
0371	4742	mov     a, re
0372	5240	sbc     a, rc
0373	1185	swap    ACC
0374	040A	xor     a, STATUS
0375	3D85	sz      ACC.3
0376	2BF0	jmp     _L44
				;195		{	
				;196			n = buff_i2c_rx[1];
0377	473E	mov     a, ra
0378	40FB	mov     n[0], a
				;197			ee_addr = buff_i2c_rx[2];
0379	472F	mov     a, buff_i2c_rx[2]
037A	40FE	mov     ee_addr[0], a
				;198			EE_Write(n, ee_addr, buff_i2c_rx + 3);
037B	477E	mov     a, ee_addr[0]
037C	40EF	mov     addr, a
037D	477B	mov     a, n[0]
037E	40BE	mov     ra, a
037F	0FB0	mov     a, B0H
0380	40F0	mov     buff, a
0381	0F00	mov     a, 0H
0382	40F1	mov     num, a
0383	473E	mov     a, ra
0384	2126	call    _EE_Write
0385	2BEE	jmp     _L53
				;199	
				;200			Clear_Rx();		
				;201		}
				;202		else if ((buff_i2c_rx[0] == 0x06) && (ptr_i2c_rx_buff >= 1)) // read key status
				_L42:
0386	477F	mov     a, ee_addr[1]
0387	0A06	sub     a, 6H
0388	390A	snz     Z
0389	2B90	jmp     _L36
038A	5081	sz      ptr_i2c_rx_buff[0]
038B	2B8D	jmp     _LI8
038C	2BF0	jmp     _L44
				;203		{					
				;204			buff_i2c_tx[0] = key_stat;
				_LI8:
038D	4702	mov     a, key_stat[0]
038E	409A	mov     buff_i2c_tx[0], a
038F	2BEE	jmp     _L53
				;205			Clear_Rx();
				;206		}	
				;207		else if ((buff_i2c_rx[0] == 0x20) && (ptr_i2c_rx_buff >= 2)) // SET LED Current Level
				_L36:
0390	477F	mov     a, ee_addr[1]
0391	0A20	sub     a, 20H
0392	390A	snz     Z
0393	2B9B	jmp     _L38
0394	0F01	mov     a, 1H
0395	4201	sub     a, ptr_i2c_rx_buff[0]
0396	3C0A	sz      C
0397	2BF0	jmp     _L44
				;208		{
				;209			Led_Current_Set(buff_i2c_rx[1]);
0398	472E	mov     a, buff_i2c_rx[1]
0399	217F	call    _Led_Current_Set
039A	2BEE	jmp     _L53
				;210			Clear_Rx();			
				;211		}
				;212		else if ((buff_i2c_rx[0] == 0x21) && (ptr_i2c_rx_buff >= 5)) // SET LED flash period and duty
				_L38:
039B	477F	mov     a, ee_addr[1]
039C	0A21	sub     a, 21H
039D	390A	snz     Z
039E	2BAC	jmp     _L41
039F	0F04	mov     a, 4H
03A0	4201	sub     a, ptr_i2c_rx_buff[0]
03A1	3C0A	sz      C
03A2	2BF0	jmp     _L44
				;213		{
				;214			led_duty= (buff_i2c_rx[1] << 8) | buff_i2c_rx[2];
03A3	472E	mov     a, buff_i2c_rx[1]
03A4	4089	mov     led_duty[1], a
03A5	472F	mov     a, buff_i2c_rx[2]
03A6	4088	mov     led_duty[0], a
				;215			led_period= (buff_i2c_rx[3] << 8) | buff_i2c_rx[4];
03A7	4730	mov     a, buff_i2c_rx[3]
03A8	408B	mov     led_period[1], a
03A9	4731	mov     a, buff_i2c_rx[4]
03AA	408A	mov     led_period[0], a
03AB	2BEE	jmp     _L53
				;216			Clear_Rx();			
				;217		}				
				;218		else if ((buff_i2c_rx[0] == 0x10) && (ptr_i2c_rx_buff >= 3)) // read test buffer
				_L41:
03AC	477F	mov     a, ee_addr[1]
03AD	0A10	sub     a, 10H
03AE	390A	snz     Z
03AF	2BD8	jmp     _L43
03B0	0F02	mov     a, 2H
03B1	4201	sub     a, ptr_i2c_rx_buff[0]
03B2	3C0A	sz      C
03B3	2BF0	jmp     _L44
				;219		{
				;220			n = buff_i2c_rx[1];
03B4	472E	mov     a, buff_i2c_rx[1]
03B5	40FB	mov     n[0], a
				;221			ee_addr = buff_i2c_rx[2];	
03B6	472F	mov     a, buff_i2c_rx[2]
03B7	40FE	mov     ee_addr[0], a
				;222	//		if ((n + ee_addr) > 8)
				;223	//			n = 8 - ee_addr;
				;224					
				;225			for (i = 0; i < n; i++)
03B8	5F7C	clr     i[0]
				_L45:
03B9	477C	mov     a, i[0]
03BA	427B	sub     a, n[0]
03BB	3C0A	sz      C
03BC	2BEE	jmp     _L53
03D6	54FC	inc     i[0]
03D7	2BB9	jmp     _L45
				;226			{
				;227				buff_i2c_tx[i] = buff_test[ee_addr + i];			
03BD	477E	mov     a, ee_addr[0]
03BE	40BF	mov     rb, a
03BF	5F40	clr     rc
03C0	477C	mov     a, i[0]
03C1	43BF	addm    a, rb
03C2	3C0A	sz      C
03C3	54C0	inc     rc
03C4	0F92	mov     a, 92H
03C5	433F	add     a, rb
03C6	0083	mov     MP1, a
03C7	0F00	mov     a, 0H
03C8	5340	adc     a, rc
03C9	0081	mov     MP0, a
03CA	24C1	call    L04C1
03CB	40BE	mov     ra, a
03CC	0F9A	mov     a, 9AH
03CD	437C	add     a, i[0]
03CE	0083	mov     MP1, a
03CF	0F00	mov     a, 0H
03D0	1F01	clr     MP0
03D1	1381	adcm    a, MP0
03D2	0701	mov     a, MP0
03D3	0084	mov     BP, a
03D4	473E	mov     a, ra
03D5	0082	mov     __iar1[0], a
				;228			}	
				;229			
				;230			Clear_Rx();			
				;231		}
				;232		else if ((buff_i2c_rx[0] == 0x11) && (ptr_i2c_rx_buff >= 3)) // write test buffer
				_L43:
03D8	477F	mov     a, ee_addr[1]
03D9	0A11	sub     a, 11H
03DA	390A	snz     Z
03DB	2BF0	jmp     _L44
03DC	0F02	mov     a, 2H
03DD	4201	sub     a, ptr_i2c_rx_buff[0]
03DE	3C0A	sz      C
03DF	2BF0	jmp     _L44
				;233		{
				;234			ee_addr = buff_i2c_rx[1];
03E0	472E	mov     a, buff_i2c_rx[1]
03E1	40FE	mov     ee_addr[0], a
				;235			ee_data = buff_i2c_rx[2];
03E2	472F	mov     a, buff_i2c_rx[2]
03E3	40FD	mov     ee_data[0], a
				;236			buff_test[ee_addr] = ee_data;
03E4	0F92	mov     a, 92H
03E5	437E	add     a, ee_addr[0]
03E6	0083	mov     MP1, a
03E7	0F00	mov     a, 0H
03E8	1F01	clr     MP0
03E9	1381	adcm    a, MP0
03EA	0701	mov     a, MP0
03EB	0084	mov     BP, a
03EC	477D	mov     a, ee_data[0]
03ED	0082	mov     __iar1[0], a
				;237	
				;238			Clear_Rx();			
				_L53:
03EE	2024	call    _Clear_Rx
03EF	2BF1	jmp     _L30
				;239		}	
				;240	//	else if ((buff_i2c_rx[0] == 0xF0) && (ptr_i2c_rx_buff >= 1)) // write test buffer
				;241	//	{
				;242	//		Power_On_Reset();
				;243	//		Clear_Rx();			
				;244	//	}		
				;245	//	else if ((buff_i2c_rx[0] == 0x06) && (ptr_i2c_rx_buff == 1)) // Read EEPROM status
				;246	//	{
				;247	//		//buff_i2c_tx[0] = b_ee_data_ready;		
				;248	//		buff_i2c_rx[0] = 0xff;
				;249	//		ptr_i2c_rx_buff = 0 ;	
				;250	//		GCC_NOP();		
				;251	//	}	
				;252		else
				;253		{
				;254			FeedWatchDog();
				_L44:
03F0	0001	clr     wdt
				_L30:
03F1	0003	ret
				;255		}
				;256	}
				;257	
				;258	void Init_System(void)
				;259	{
				;260		WDT_SET(OFF);
				_Init_System:
				_Init_System:
01AD	0FAF	mov     a, AFH
01AE	009A	mov     WDTC, a
				;261		
				;262		_acerl = 0x00; //disable ADC
01AF	1F43	clr     ACERL
				;263		_cos = 1; //CX disabled
01B0	31BE	set     COS
				;264		_csel = 0; // disable C+, C-
01B1	37BE	clr     CSEL
				;265		
				;266	/* I/O */
				;267		Led_Current_Set(0);	
01B2	0F00	mov     a, 0H
01B3	217F	call    _Led_Current_Set
				;268		// 7 segments output
				;269		SA = 0;
01B4	3425	clr     PB0
				;270		SB = 0;
01B5	34A5	clr     PB1
				;271		SC = 0;
01B6	3525	clr     PB2
				;272		SD = 0;
01B7	35C0	clr     PC3
				;273		SE = 0;
01B8	3640	clr     PC4
				;274		SF = 0;
01B9	3614	clr     PA4
				;275		SG = 0;
01BA	3694	clr     PA5
				;276		DOT = 0;
01BB	3714	clr     PA6
				;277		C1 = 0;
01BC	3794	clr     PA7
				;278		C2 = 0;
01BD	35A5	clr     PB3
				;279		C3 = 0;			
01BE	3625	clr     PB4
				;280		_pac4 = 0; 
01BF	3615	clr     PAC4
				;281		_pac5 = 0;
01C0	3695	clr     PAC5
				;282		_pac6 = 0;
01C1	3715	clr     PAC6
				;283		_pac7 = 0;
01C2	3795	clr     PAC7
				;284			
				;285		_pbc0 = 0; 
01C3	3426	clr     PBC0
				;286		_pbc1 = 0; 
01C4	34A6	clr     PBC1
				;287		_pbc2 = 0;
01C5	3526	clr     PBC2
				;288		_pbc3 = 0;
01C6	35A6	clr     PBC3
				;289		_pbc4 = 0;
01C7	3626	clr     PBC4
				;290				
				;291		_pcc3 = 0;
01C8	35C1	clr     PCC3
				;292		_pcc4 = 0;
01C9	3641	clr     PCC4
				;293	
				;294	
				;295		// keys, pull up
				;296		_pcpu0 = 1;
01CA	3042	set     PCPU0
				;297		_pcpu1 = 1;
01CB	30C2	set     PCPU1
				;298		_pcpu2 = 1;
01CC	3142	set     PCPU2
				;299		_papu1 = 1;
01CD	3096	set     PAPU1
				;300		_papu3 = 1;
01CE	3196	set     PAPU3
				;301		_pbpu5 = 1;
01CF	32A7	set     PBPU5
				;302		_pbpu6 = 1;
01D0	3327	set     PBPU6
				;303		
				;304		KS1 = 1;
01D1	3040	set     PC0
				;305		KS2 = 1;
01D2	30C0	set     PC1
				;306		KS3 = 1;
01D3	3140	set     PC2
				;307		KS4 = 1;
01D4	3094	set     PA1
				;308		KS5 = 1;
01D5	3194	set     PA3
				;309		KS6 = 1;
01D6	3325	set     PB6
				;310		KS7 = 1;
01D7	32A5	set     PB5
				;311		
				;312	/* UART */
				;313	//	_uartf = 0; 	//interrupt enable
				;314	//	_uarte = 1;
				;315	//	_rie = 1; 
				;316	//	
				;317	//	_brgh = 1; 		// high speed
				;318	//	_brg = 77; 		// 9600 bps
				;319	//	_uarten = 1; 	// pins switched to TX,RX
				;320	//	_txen = 0;	
				;321	//	_rxen = 0;
				;322	
				;323	/* slave I2C */
				;324		_iicen = 1; // enable I2C
01D8	30C9	set     IICEN
				;325		_i2cdbnc0 = 1;
01D9	3149	set     I2CDBNC0
				;326		_i2cdbnc1 = 1;
01DA	31C9	set     I2CDBNC1
				;327		_pcc5 = 1;
01DB	32C1	set     PCC5
				;328		_pcc6 = 1;
01DC	3341	set     PCC6
				;329		_pcps3 = 1; // driving current
01DD	31D2	set     PCPS3
				;330		_pcps2 = 1;
01DE	3152	set     PCPS2
				;331		SDA = 1;
01DF	32C0	set     PC5
				;332		SCL = 1;
01E0	3340	set     PC6
				;333		_pcpu5 = 1; //I2C bus pull high
01E1	32C2	set     PCPU5
				;334		_pcpu6 = 1;
01E2	3342	set     PCPU6
				;335	
				;336		_iica = I2C_ADDR;
01E3	0F70	mov     a, 70H
01E4	00CC	mov     IICA, a
				;337	//	_iichtx = 0;  // receive mode
				;338	//	_iictxak = 0; // send ack
				;339	//	_i2ctoc = 0b10111111;  // time out is enabled
				;340		
				;341		_iicf = 0;
01E5	3710	clr     IICF
				;342		_iice = 1; // I2C interrupt
01E6	3110	set     IICE
				;343		
				;344	/* Time base 
				;345	Bit    7    6    5     4   3     2    1    0
				;346	Name TBON TBCK TB11 TB10 LXTLP TB02 TB01 TB00
				;347	TB0==
				;348	000: 256/fTB
				;349	001: 512/fTB
				;350	010: 1024/fTB
				;351	011: 2048/fTB
				;352	100: 4096/fTB
				;353	101: 8192/fTB
				;354	110: 16384/fTB
				;355	111: 32768/fTB 
				;356	TB1==
				;357	00: 4096/fTB
				;358	01: 8192/fTB
				;359	10: 16384/fTB
				;360	11: 32768/fTB
				;361	*/
				;362		_tbc = 0b11110110; //fsys(12MHz)/4, tb1=32768/ftb , tb0=16384/ftb 
01E7	0FF6	mov     a, F6H
01E8	009B	mov     TBC, a
				;363		_tb0f = 0;
01E9	378F	clr     TB0F
				;364		_tb0e = 1;
01EA	318F	set     TB0E
				;365		_tb1f = 0;
01EB	3610	clr     TB1F
				;366		_tb1e = 1;	
01EC	3010	set     TB1E
01ED	0003	ret
				;367	}
				;368	
				;369	void Init_Vars(void)
				;370	{
				;371		uint8_t i;
				;372	
				;373		ptr_i2c_rx_buff = 0;
				_Init_Vars:
				_Init_Vars:
015F	5F01	clr     ptr_i2c_rx_buff[0]
				;374		ptr_i2c_tx_buff = 0;
0160	5F00	clr     ptr_i2c_tx_buff[0]
0161	0F10	mov     a, 10H
0162	40BE	mov     ra, a
				;375	
				;376		for (i = 0; i < BUFF_LEN ; i++)
0163	5F41	clr     rd
017B	54C1	inc     rd
017C	57BE	sdz     ra
017D	2964	jmp     _L3
017E	0003	ret
				;377		{
				;378			buff_i2c_rx[i] = 0;
				_L3:
0164	4741	mov     a, rd
0165	40BF	mov     rb, a
0166	5F40	clr     rc
0167	0FAD	mov     a, ADH
0168	433F	add     a, rb
0169	0083	mov     MP1, a
016A	0F00	mov     a, 0H
016B	5340	adc     a, rc
016C	0081	mov     MP0, a
016D	0701	mov     a, MP0
016E	0084	mov     BP, a
016F	0F00	mov     a, 0H
0170	0082	mov     __iar1[0], a
				;379			buff_i2c_tx[i] = 0;
0171	0F9A	mov     a, 9AH
0172	433F	add     a, rb
0173	0083	mov     MP1, a
0174	0F00	mov     a, 0H
0175	5340	adc     a, rc
0176	0081	mov     MP0, a
0177	0701	mov     a, MP0
0178	0084	mov     BP, a
0179	0F00	mov     a, 0H
017A	0082	mov     __iar1[0], a
				;380		}
				;381	}
				;382	
				;383	
				;384	void Led_Current_Set(uint8_t level)
				;385	{
				_Led_Current_Set:
				_Led_Current_Set:
017F	40BE	mov     ra, a
0180	40ED	mov     level[0], a
				;386		if (level == 1) //7mA
0181	573E	sdza    ra
0182	298B	jmp     L018B
				;387		{
				;388			_pcps1 = 0;
0183	34D2	clr     PCPS1
				;389			_pcps0 = 1;
0184	3052	set     PCPS0
				;390			_paps3 = 0;
0185	35D1	clr     PAPS3
				;391			_paps2 = 1;
0186	3151	set     PAPS2
				;392			_pbps3 = 0;
0187	37D1	clr     PBPS3
				;393			_pbps2 = 1;
0188	3351	set     PBPS2
				;394			_pbps1 = 0;
0189	36D1	clr     PBPS1
018A	29A2	jmp     L01A2
				;395			_pbps0 = 1;
				;396			//_sledc0 =0b01010101;	
				;397			//_sledc1 =0b01010101;	
				;398		}
				;399		else if (level == 2) // 10mA
				L018B:
018B	476D	mov     a, level[0]
018C	0A02	sub     a, 2H
018D	390A	snz     Z
018E	2997	jmp     L0197
				;400		{
				;401			_pcps1 = 1;
018F	30D2	set     PCPS1
				;402			_pcps0 = 0;
0190	3452	clr     PCPS0
				;403			_paps3 = 1;
0191	31D1	set     PAPS3
				;404			_paps2 = 0;
0192	3551	clr     PAPS2
				;405			_pbps3 = 1;
0193	33D1	set     PBPS3
				;406			_pbps2 = 0;
0194	3751	clr     PBPS2
				;407			_pbps1 = 1;
0195	32D1	set     PBPS1
0196	29AB	jmp     L01AB
				;408			_pbps0 = 0;		
				;409			//_sledc0 =0b10101010;	
				;410			//_sledc1 =0b10101010;	
				;411		}	
				;412		else if (level == 3) // 22mA
				L0197:
0197	476D	mov     a, level[0]
0198	0A03	sub     a, 3H
0199	390A	snz     Z
019A	29A4	jmp     L01A4
				;413		{
				;414			_pcps1 = 1;
019B	30D2	set     PCPS1
				;415			_pcps0 = 1;
019C	3052	set     PCPS0
				;416			_paps3 = 1;
019D	31D1	set     PAPS3
				;417			_paps2 = 1;
019E	3151	set     PAPS2
				;418			_pbps3 = 1;
019F	33D1	set     PBPS3
				;419			_pbps2 = 1;
01A0	3351	set     PBPS2
				;420			_pbps1 = 1;
01A1	32D1	set     PBPS1
				;421			_pbps0 = 1;			
				L01A2:
01A2	3251	set     PBPS0
01A3	29AC	jmp     L01AC
				;422			//_sledc0 =0b11111111;	
				;423			//_sledc1 =0b11111111;	
				;424		}
				;425		else	// 4mA
				;426		{
				;427			_pcps1 = 0;
				L01A4:
01A4	34D2	clr     PCPS1
				;428			_pcps0 = 0;
01A5	3452	clr     PCPS0
				;429			_paps3 = 0;
01A6	35D1	clr     PAPS3
				;430			_paps2 = 0;
01A7	3551	clr     PAPS2
				;431			_pbps3 = 0;
01A8	37D1	clr     PBPS3
				;432			_pbps2 = 0;
01A9	3751	clr     PBPS2
				;433			_pbps1 = 0;
01AA	36D1	clr     PBPS1
				;434			_pbps0 = 0;			
				L01AB:
01AB	3651	clr     PBPS0
				L01AC:
01AC	0003	ret
				;435			//_sledc0	= 0x00;
				;436			//_sledc1 = 0x00;		
				;437		}		
				;438	}
				;439	
				;440	/* led: B7  B6 B5 B4 B3 B2 B1 B0
				;441	        =========================
				;442	        DOT SG SF SE SD SC SB SA 
				;443	*/
				;444	void Digit_Set(uint8_t led)
				;445	{
				_Digit_Set:
				_Digit_Set:
01EE	40C5	mov     ra1c, a
01EF	40E8	mov     led[0], a
				;446		SA = (led >> 0) & 0x01;
01F0	0F01	mov     a, 1H
01F1	46C5	andm    a, ra1c
01F2	3425	clr     PB0
01F3	4745	mov     a, ra1c
01F4	05A5	orm     a, PB
				;447		SB = (led >> 1) & 0x01;
01F5	5F45	clr     ra1c
01F6	7CE8	sz      led[0].1
01F7	54C5	inc     ra1c
01F8	4745	mov     a, ra1c
01F9	43C5	addm    a, ra1c
01FA	34A5	clr     PB1
01FB	4745	mov     a, ra1c
01FC	05A5	orm     a, PB
				;448		SC = (led >> 2) & 0x01;
01FD	5F45	clr     ra1c
01FE	7D68	sz      led[0].2
01FF	7145	set     ra1c.2
0200	3525	clr     PB2
0201	4745	mov     a, ra1c
0202	05A5	orm     a, PB
				;449		SD = (led >> 3) & 0x01;
0203	4768	mov     a, led[0]
0204	0E08	and     a, 8H
0205	40C5	mov     ra1c, a
0206	35C0	clr     PC3
0207	4745	mov     a, ra1c
0208	05C0	orm     a, PC
				;450		SE = (led >> 4) & 0x01;
0209	4768	mov     a, led[0]
020A	0E10	and     a, 10H
020B	40C5	mov     ra1c, a
020C	3640	clr     PC4
020D	4745	mov     a, ra1c
020E	05C0	orm     a, PC
				;451		SF = (led >> 5) & 0x01;
020F	5F45	clr     ra1c
0210	7EE8	sz      led[0].5
0211	54C5	inc     ra1c
0212	5145	swapa   ra1c
0213	0EF0	and     a, F0H
0214	40C5	mov     ra1c, a
0215	3614	clr     PA4
0216	4745	mov     a, ra1c
0217	0594	orm     a, PA
				;452		SG = (led >> 6) & 0x01;
0218	5F45	clr     ra1c
0219	7F68	sz      led[0].6
021A	54C5	inc     ra1c
021B	5145	swapa   ra1c
021C	1885	rl      ACC
021D	0EE0	and     a, E0H
021E	40C5	mov     ra1c, a
021F	3694	clr     PA5
0220	4745	mov     a, ra1c
0221	0594	orm     a, PA
0222	0003	ret
				;453		//DOT = (led >> 7) & 0x01;	
				;454	}
				;455	
				;456	void Com_Sel(uint8_t sel)
				;457	{ 
				_Com_Sel:
				_Com_Sel:
0223	40E8	mov     sel[0], a
				;458		C1 = 0;
0224	3794	clr     PA7
				;459		C2 = 0;
0225	35A5	clr     PB3
				;460		C3 = 0;
0226	3625	clr     PB4
				;461		
				;462		if (sel == 0)
0227	50E8	sz      sel[0]
0228	2A2B	jmp     L022B
				;463		{
				;464			C1 = 1;
0229	3394	set     PA7
022A	2A34	jmp     L0234
				;465		}
				;466		else 	if (sel == 1)
				L022B:
022B	5768	sdza    sel[0]
022C	2A2F	jmp     L022F
				;467		{
				;468			C2 = 1;
022D	31A5	set     PB3
022E	2A34	jmp     L0234
				;469		}
				;470		else 	if (sel == 2)
				L022F:
022F	4768	mov     a, sel[0]
0230	0A02	sub     a, 2H
0231	390A	snz     Z
0232	2A34	jmp     L0234
				;471		{
				;472			C3 = 1;
0233	3225	set     PB4
				L0234:
0234	0003	ret
				;473		}
				;474	}
				;475	
				;476	void Led_Scan(void)
				;477	{
				;478		uint8_t digit = 'O';
				;479		static uint32_t led_tmr = 0;
				;480		
				;481	/* scan the 7-segment display */
				;482		Digit_Set(0x00);
				_Led_Scan:
				_Led_Scan:
0235	0F00	mov     a, 0H
0236	21EE	call    _Digit_Set
				;483		
				;484		if (led_tmr <= led_duty)
0237	470E	mov     a, led_tmr[0]
0238	40E9	mov     _Led_Scan_2, a
0239	470F	mov     a, led_tmr[1]
023A	40EA	mov     _Led_Scan_2[1], a
023B	4710	mov     a, led_tmr[2]
023C	40EB	mov     _Led_Scan_2[2], a
023D	4711	mov     a, led_tmr[3]
023E	40EC	mov     _Led_Scan_2[3], a
023F	4708	mov     a, led_duty[0]
0240	4269	sub     a, _Led_Scan_2
0241	4709	mov     a, led_duty[1]
0242	526A	sbc     a, _Led_Scan_2[1]
0243	1F05	clr     ACC
0244	526B	sbc     a, _Led_Scan_2[2]
0245	1F05	clr     ACC
0246	526C	sbc     a, _Led_Scan_2[3]
0247	380A	snz     C
0248	2A4D	jmp     _L19
				;485			Com_Sel(com);
0249	470C	mov     a, com[0]
024A	40C5	mov     ra1c, a
024B	4745	mov     a, ra1c
024C	2A4E	jmp     _L26
				;486		else
				;487			Com_Sel(8);	
				_L19:
024D	0F08	mov     a, 8H
				_L26:
024E	2223	call    _Com_Sel
				;488	
				;489		digit = height_str[com];	
024F	0F83	mov     a, 83H
0250	430C	add     a, com[0]
0251	0083	mov     MP1, a
0252	0F00	mov     a, 0H
0253	1F01	clr     MP0
0254	1381	adcm    a, MP0
0255	24C1	call    L04C1
0256	40C5	mov     ra1c, a
				;490		if ((digit >= '0') && (digit <= '9'))
0257	4745	mov     a, ra1c
0258	0BD0	add     a, D0H
0259	40C6	mov     rb1c, a
025A	0F09	mov     a, 9H
025B	4246	sub     a, rb1c
025C	3C0A	sz      C
025D	2A68	jmp     _L27
				;491		{
				;492			digit = digit - '0';
				;493			Digit_Set(seg_7_table[digit]);
				;494		}
				;495		else if ((digit >= 'A') && (digit <= 'F'))
025E	4745	mov     a, ra1c
025F	0BBF	add     a, BFH
0260	40C6	mov     rb1c, a
0261	0F05	mov     a, 5H
0262	4246	sub     a, rb1c
0263	380A	snz     C
0264	2A73	jmp     _L22
				;496		{
				;497			digit = digit - 'A' + 10;
0265	4745	mov     a, ra1c
0266	0BC9	add     a, C9H
0267	40C6	mov     rb1c, a
				;498			Digit_Set(seg_7_table[digit]);
				_L27:
0268	5F47	clr     rc1c
0269	7FC6	sz      rb1c.7
026A	5FC7	set     rc1c
026B	0F17	mov     a, 17H
026C	4346	add     a, rb1c
026D	0083	mov     MP1, a
026E	0F80	mov     a, 80H
026F	5347	adc     a, rc1c
0270	0081	mov     MP0, a
0271	24C1	call    L04C1
0272	21EE	call    _Digit_Set
				;499		}
				;500		
				;501		if (com >= 2)
				_L22:
0273	0F01	mov     a, 1H
0274	420C	sub     a, com[0]
0275	3C0A	sz      C
0276	2A94	jmp     _L23
				;502		{	
				;503			com = 0;
0277	5F0C	clr     com[0]
				;504			if (led_tmr >= led_period)
0278	50EC	sz      _Led_Scan_2[3]
0279	2A82	jmp     _LI2
027A	50EB	sz      _Led_Scan_2[2]
027B	2A82	jmp     _LI2
027C	4769	mov     a, _Led_Scan_2
027D	420A	sub     a, led_period[0]
027E	476A	mov     a, _Led_Scan_2[1]
027F	520B	sbc     a, led_period[1]
0280	380A	snz     C
0281	2A87	jmp     _L24
				;505				led_tmr = 0;
				_LI2:
0282	5F0E	clr     led_tmr[0]
0283	5F0F	clr     led_tmr[1]
0284	5F10	clr     led_tmr[2]
0285	5F11	clr     led_tmr[3]
0286	2A95	jmp     _L18
				;506			else
				;507				led_tmr++;
				_L24:
0287	0F01	mov     a, 1H
0288	4369	add     a, _Led_Scan_2
0289	408E	mov     led_tmr[0], a
028A	0F00	mov     a, 0H
028B	536A	adc     a, _Led_Scan_2[1]
028C	408F	mov     led_tmr[1], a
028D	0F00	mov     a, 0H
028E	536B	adc     a, _Led_Scan_2[2]
028F	4090	mov     led_tmr[2], a
0290	0F00	mov     a, 0H
0291	536C	adc     a, _Led_Scan_2[3]
0292	4091	mov     led_tmr[3], a
0293	2A95	jmp     _L18
				;508		}
				;509		else
				;510			com ++;	
				_L23:
0294	548C	inc     com[0]
				_L18:
0295	0003	ret
				;511	}	
				;512	
				;513	uint8_t Key_Scan(void)
				;514	{
				;515		return ~(0x80 | (KS7 << 6) | (KS6 << 5) | (KS5 << 4) | (KS4 << 3) | (KS3 << 2) | (KS2 << 1) | (KS1 << 0));
				_Key_Scan:
				_Key_Scan:
0296	5F48	clr     rd20
0297	3EA5	sz      PB5
0298	54C8	inc     rd20
0299	5F49	clr     rb20
029A	3F25	sz      PB6
029B	54C9	inc     rb20
029C	5F4A	clr     rf20
029D	3D94	sz      PA3
029E	54CA	inc     rf20
029F	5F4B	clr     rg20
02A0	3C94	sz      PA1
02A1	54CB	inc     rg20
02A2	5F4C	clr     rh20
02A3	3D40	sz      PC2
02A4	54CC	inc     rh20
02A5	5F4D	clr     ra20
02A6	3CC0	sz      PC1
02A7	54CD	inc     ra20
02A8	0740	mov     a, PC
02A9	0E01	and     a, 1H
02AA	40CE	mov     rc20, a
02AB	73CE	set     rc20.7
02AC	5F4F	clr     re20
02AD	0F06	mov     a, 6H
				_LI3:
02AE	340A	clr     C
02AF	5AC8	rlc     rd20
02B0	5ACF	rlc     re20
02B1	1785	sdz     ACC
02B2	2AAE	jmp     _LI3
02B3	474E	mov     a, rc20
02B4	45C8	orm     a, rd20
02B5	5F4E	clr     rc20
02B6	0F05	mov     a, 5H
				_LI4:
02B7	340A	clr     C
02B8	5AC9	rlc     rb20
02B9	5ACE	rlc     rc20
02BA	1785	sdz     ACC
02BB	2AB7	jmp     _LI4
02BC	4749	mov     a, rb20
02BD	45C8	orm     a, rd20
02BE	474A	mov     a, rf20
02BF	40C9	mov     rb20, a
02C0	5F4E	clr     rc20
02C1	0F04	mov     a, 4H
				_LI5:
02C2	340A	clr     C
02C3	5AC9	rlc     rb20
02C4	5ACE	rlc     rc20
02C5	1785	sdz     ACC
02C6	2AC2	jmp     _LI5
02C7	4749	mov     a, rb20
02C8	45C8	orm     a, rd20
02C9	474B	mov     a, rg20
02CA	40CA	mov     rf20, a
02CB	5F4B	clr     rg20
02CC	0F03	mov     a, 3H
				_LI6:
02CD	340A	clr     C
02CE	5ACA	rlc     rf20
02CF	5ACB	rlc     rg20
02D0	1785	sdz     ACC
02D1	2ACD	jmp     _LI6
02D2	474A	mov     a, rf20
02D3	45C8	orm     a, rd20
02D4	474C	mov     a, rh20
02D5	40CA	mov     rf20, a
02D6	5F4B	clr     rg20
02D7	340A	clr     C
02D8	5ACA	rlc     rf20
02D9	5ACB	rlc     rg20
02DA	340A	clr     C
02DB	5ACA	rlc     rf20
02DC	5ACB	rlc     rg20
02DD	4748	mov     a, rd20
02DE	45CA	orm     a, rf20
02DF	474D	mov     a, ra20
02E0	43CD	addm    a, ra20
02E1	474D	mov     a, ra20
02E2	45CA	orm     a, rf20
02E3	414A	cpla    rf20
02E4	40CA	mov     rf20, a
				;516	}
02E5	474A	mov     a, rf20
02E6	0003	ret
				;517	
				;518	void Clear_Rx(void)
				;519	{
				;520		buff_i2c_rx[0] = 0xff;
				@dummy32 .SECTION 'CODE'
				_Clear_Rx:
				_Clear_Rx:
0024	5FAD	set     buff_i2c_rx[0]
				;521		ptr_i2c_rx_buff = 0 ;
0025	5F01	clr     ptr_i2c_rx_buff[0]
0026	0003	ret
0027	0000	nop
				;522	}			
				;523	/*---------------------------------------------------------------
				;524		Interrupt Subroutines
				;525	-----------------------------------------------------------------
				;526	*/
				;527	DEFINE_ISR(Int_Tb0, 0x1C) //
				;528	{			
				@Int_Tb0_code .SECTION 'CODE'
001C	40D0	mov     r11c, a
001D	0704	mov     a, BP
001E	40D1	mov     r21c, a
001F	2BF2	jmp     _Int_Tb0
				_Int_Tb0:
				_Int_Tb0:
03F2	070A	mov     a, STATUS
03F3	40D2	mov     r31c, a
03F4	0703	mov     a, MP1
03F5	40D3	mov     r41c, a
03F6	0701	mov     a, MP0
03F7	40D4	mov     r51c, a
03F8	0707	mov     a, TBLP
03F9	40D5	mov     r61c, a
03FA	0709	mov     a, TBHP
03FB	40D6	mov     r71c, a
				;529		
				;530		FeedWatchDog();
03FC	0001	clr     wdt
				;531		Led_Scan();	
03FD	2235	call    _Led_Scan
				;532		_tb0f = 0;
03FE	378F	clr     TB0F
03FF	4751	mov     a, r21c
0400	0084	mov     BP, a
0401	4752	mov     a, r31c
0402	008A	mov     STATUS, a
0403	4753	mov     a, r41c
0404	0083	mov     MP1, a
0405	4754	mov     a, r51c
0406	0081	mov     MP0, a
0407	4755	mov     a, r61c
0408	0087	mov     TBLP, a
0409	4756	mov     a, r71c
040A	0089	mov     TBHP, a
040B	1D05	tabrd   ACC
040C	4750	mov     a, r11c
040D	0004	reti
				;533	}
				;534	
				;535	DEFINE_ISR(Int_Tb1, 0x20) //
				;536	{		
				@Int_Tb1_code .SECTION 'CODE'
				@dummy28 .SECTION 'CODE'
0020	40D7	mov     r120, a
0021	0704	mov     a, BP
0022	40D8	mov     r220, a
0023	2C0E	jmp     _Int_Tb1
				_Int_Tb1:
				_Int_Tb1:
040E	070A	mov     a, STATUS
040F	40D9	mov     r320, a
0410	0703	mov     a, MP1
0411	40DA	mov     r420, a
0412	0701	mov     a, MP0
0413	40DB	mov     r520, a
0414	0707	mov     a, TBLP
0415	40DC	mov     r620, a
0416	0709	mov     a, TBHP
0417	40DD	mov     r720, a
				;537		static uint8_t cnt = 0;
				;538		FeedWatchDog();	
0418	0001	clr     wdt
				;539	/* Read Key */	
				;540		key_stat = Key_Scan();	
0419	2296	call    _Key_Scan
041A	40CD	mov     ra20, a
041B	474D	mov     a, ra20
041C	4082	mov     key_stat[0], a
				;541		
				;542		if (cnt++ > 10)
041D	470D	mov     a, cnt[0]
041E	40CD	mov     ra20, a
041F	0F0A	mov     a, AH
0420	424D	sub     a, ra20
0421	380A	snz     C
0422	2C26	jmp     _L59
0423	544D	inca    ra20
0424	408D	mov     cnt[0], a
0425	2C2C	jmp     _L60
				;543		{
				;544			cnt = 0;
				_L59:
0426	5F0D	clr     cnt[0]
				;545			
				;546			if (BUZZER == 1)
0427	3B14	snz     PA6
0428	2C2B	jmp     _L61
				;547				BUZZER = 0;
0429	3714	clr     PA6
042A	2C2C	jmp     _L60
				;548			else
				;549				BUZZER = 1;
				_L61:
042B	3314	set     PA6
				;550		}
				;551				
				;552		_tb1f = 0;
				_L60:
042C	3610	clr     TB1F
042D	4758	mov     a, r220
042E	0084	mov     BP, a
042F	4759	mov     a, r320
0430	008A	mov     STATUS, a
0431	475A	mov     a, r420
0432	0083	mov     MP1, a
0433	475B	mov     a, r520
0434	0081	mov     MP0, a
0435	475C	mov     a, r620
0436	0087	mov     TBLP, a
0437	475D	mov     a, r720
0438	0089	mov     TBHP, a
0439	1D05	tabrd   ACC
043A	4757	mov     a, r120
043B	0004	reti
				;553	}
				;554	
				;555	DEFINE_ISR(Int_UART, 0x2C)
				;556	{
				@dummy40 .SECTION 'CODE'
				@Int_UART_code .SECTION 'CODE'
002C	40DE	mov     r12c, a
002D	070A	mov     a, STATUS
002E	40DF	mov     r22c, a
002F	2C3C	jmp     _Int_UART
				;557		//volatile uint8_t temp, i;
				;558		
				;559		FeedWatchDog();
				_Int_UART:
				_Int_UART:
043C	0001	clr     wdt
				;560		
				;561	//	if (_rxif == 1)
				;562	//	{
				;563	//		temp = _txr_rxr;
				;564	//		if (temp == '@')
				;565	//		{
				;566	//			ptr_uart_rx_buff = 0;
				;567	//			uart_rx_received = 0;				
				;568	//			for (i = 0; i < BUFF_LEN ; i++)
				;569	//			{
				;570	//				buff_uart_rx[i] = 0;
				;571	//			}			
				;572	//		}
				;573	//		else if ((temp == 0) || (temp == '#'))
				;574	//		{
				;575	//			uart_rx_received = 1;				
				;576	//		}
				;577	//		else
				;578	//		{
				;579	//			if (ptr_uart_rx_buff < BUFF_LEN)
				;580	//			{
				;581	//				buff_uart_rx[ptr_uart_rx_buff] =	temp;
				;582	//				ptr_uart_rx_buff ++;
				;583	//			}
				;584	//		}
				;585	//	}
				;586		
				;587		_uartf = 0;
043D	3790	clr     UARTF
043E	475F	mov     a, r22c
043F	008A	mov     STATUS, a
0440	475E	mov     a, r12c
0441	0004	reti
				;588	}
				;589	
				;590	DEFINE_ISR(Int_I2C, 0x28)
				;591	{
				@Int_I2C_code .SECTION 'CODE'
0028	40E0	mov     r128, a
0029	0704	mov     a, BP
002A	40E1	mov     r228, a
002B	2C42	jmp     _Int_I2C
				_Int_I2C:
				_Int_I2C:
0442	070A	mov     a, STATUS
0443	40E2	mov     r328, a
0444	0703	mov     a, MP1
0445	40E3	mov     r428, a
0446	0701	mov     a, MP0
0447	40E4	mov     r528, a
0448	0707	mov     a, TBLP
0449	40E5	mov     r628, a
044A	0709	mov     a, TBHP
044B	40E6	mov     r728, a
				;592		volatile uint8_t u8temp;
				;593		EMI_OFF();
044C	300E	set     EMI
				;594		
				;595		FeedWatchDog();
044D	0001	clr     wdt
				;596		if (I2C_TIMEOUT == 1)
044E	3B4D	snz     I2CTOF
044F	2C53	jmp     L0453
				;597		{
				;598			I2C_TIMEOUT_EN = 1;
0450	33CD	set     I2CTOEN
				;599			I2C_TIMEOUT = 0;
0451	374D	clr     I2CTOF
0452	2C7D	jmp     L047D
				;600		}
				;601		else 
				;602		{
				;603			if (I2C_ADDR_MATCH == 1)	// address match
				L0453:
0453	3B4A	snz     IICHAAS
0454	2C5A	jmp     L045A
				;604			{
				;605				ptr_i2c_tx_buff = 0;
0455	5F00	clr     ptr_i2c_tx_buff[0]
				;606				if (I2C_READ == 1) // master request data
0456	394A	snz     IICSRW
0457	2C79	jmp     L0479
				;607				{
				;608					I2C_TRANSMITTER = 1;
0458	324A	set     IICHTX
0459	2C6F	jmp     L046F
				;609					//ptr_i2c_tx_buff = 0;
				;610					I2C_DATA = buff_i2c_tx[ptr_i2c_tx_buff];
				;611					ptr_i2c_tx_buff++;			
				;612				}	
				;613				else // master feed data
				;614				{
				;615					I2C_TRANSMITTER = 0;
				;616					I2C_TX_NOACK = 0;				
				;617					//ptr_i2c_rx_buff = 0;
				;618					u8temp = I2C_DATA; //dummy read
				;619				}
				;620			}
				;621			else  // data transfer
				;622			{
				;623				if (I2C_TRANSMITTER == 0) // master feed data
				L045A:
045A	3E4A	sz      IICHTX
045B	2C6D	jmp     L046D
				;624				{
				;625					if (ptr_i2c_rx_buff < (BUFF_LEN - 1))
045C	0F0E	mov     a, EH
045D	4201	sub     a, ptr_i2c_rx_buff[0]
045E	380A	snz     C
045F	2C7D	jmp     L047D
				;626					{	
				;627						buff_i2c_rx[ptr_i2c_rx_buff] = I2C_DATA;				
0460	0FAD	mov     a, ADH
0461	4301	add     a, ptr_i2c_rx_buff[0]
0462	0083	mov     MP1, a
0463	0F00	mov     a, 0H
0464	1F01	clr     MP0
0465	1381	adcm    a, MP0
0466	0701	mov     a, MP0
0467	0084	mov     BP, a
0468	074B	mov     a, IICD
0469	0082	mov     __iar1[0], a
				;628						GCC_NOP();						
046A	0000	nop
				;629						ptr_i2c_rx_buff ++;	 // ptr_i2c_rx_buff is the next saved buffer address	
046B	5481	inc     ptr_i2c_rx_buff[0]
046C	2C7D	jmp     L047D
				;630					}
				;631	
				;632				}
				;633				else // master request data
				;634				{
				;635					if (I2C_RX_NOACK == 0) // ack
				L046D:
046D	3C4A	sz      IICRXAK
046E	2C79	jmp     L0479
				;636					{
				;637						I2C_DATA = buff_i2c_tx[ptr_i2c_tx_buff];
				L046F:
046F	0F9A	mov     a, 9AH
0470	4300	add     a, ptr_i2c_tx_buff[0]
0471	0083	mov     MP1, a
0472	0F00	mov     a, 0H
0473	1F01	clr     MP0
0474	1381	adcm    a, MP0
0475	24C1	call    L04C1
0476	00CB	mov     IICD, a
				;638						ptr_i2c_tx_buff++;	
0477	5480	inc     ptr_i2c_tx_buff[0]
0478	2C7D	jmp     L047D
				;639					}
				;640					else // no ack, return to RX mode
				;641					{
				;642						I2C_TRANSMITTER = 0;
				L0479:
0479	364A	clr     IICHTX
				;643						I2C_TX_NOACK = 0;
047A	35CA	clr     IICTXAK
				;644						u8temp = I2C_DATA; //dummy read
047B	074B	mov     a, IICD
047C	40E7	mov     u8temp[0], a
				;645					}
				;646				}
				;647			}
				;648		}
				;649	
				;650		I2C_INT_FLAG = 0;	
				L047D:
047D	3710	clr     IICF
				;651		EMI_ON();
047E	300E	set     EMI
047F	4761	mov     a, r228
0480	0084	mov     BP, a
0481	4762	mov     a, r328
0482	008A	mov     STATUS, a
0483	4763	mov     a, r428
0484	0083	mov     MP1, a
0485	4764	mov     a, r528
0486	0081	mov     MP0, a
0487	4765	mov     a, r628
0488	0087	mov     TBLP, a
0489	4766	mov     a, r728
048A	0089	mov     TBHP, a
048B	1D05	tabrd   ACC
048C	4760	mov     a, r128
048D	0004	reti
				startup_value:
				@ROMDATA_BASE .SECTION 'CODE'
048E	000D	dc	0000DH
048F	0080	mov     [00H], a
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
0490	0000	nop
0491	4600	and     a, ptr_i2c_tx_buff[0]
0492	4646	and     a, rb1c
0493	0000	nop
				;652	}
				;653	
				;654	void Power_On_Reset(void)
				;655	{
				;656		_lvrc = 0;	
				;657	}
				;file D:\WORK\Project\Github\etable\code\I2C\startup0_l.asm
				;1	;;--------------------------------------------------------------;;
				;2	;;    This file is part of the Holtek C Compiler V3 package     ;;
				;3	;;    For the initialization of static linkage variables        ;;
				;4	;;    Copyright (C) 2017 Holtek Semiconductor Inc.              ;;
				;5	;;    Version: 1.07 (Above IDE3000 V7.94)                       ;;
				;6	;;    Date:    2017/03/06                                        ;;
				;7	;;--------------------------------------------------------------;;
				;8	
				;9	acc equ [05h]
				;10	tblp equ [07h]
				;11	tblh equ [08h]
				;12	;;tbhp equ [09h] 
				;13	mp0 equ [01h]
				;14	r1 equ [02h]
				;15	mp1l equ [03h]
				;16	mp1h equ [04h]
				;17	z equ [0ah].2
				;18	c equ [0ah].0
				;19	ifndef tbhp
				;20	tbhp equ [09h]
				;21	endif 
				;22	extern startup_value_1:near
				;23	
				;24	@start .section 'code'
				;25	begin_startup_value:
				;26	  mov a,low (offset startup_value_1) 
				begin_startup_value:
				@start .SECTION 'CODE'
				@dummy44 .SECTION 'CODE'
				_main_startup1:
				@start .SECTION 'CODE'
0030	0F8D	mov     a, 8DH
				;27	  mov tblp,a
0031	0087	mov     TBLP, a
				;28	  mov a,high (offset startup_value_1) 
0032	0F04	mov     a, 4H
				;29	  mov tbhp,a
0033	0089	mov     TBHP, a
				;30	next_table:
				;31	  ;CLR WDT
				;32	  inc tblp
				next_table:
0034	1487	inc     TBLP
				;33	  sz z
0035	3D0A	sz      Z
				;34	  inc tbhp
0036	1489	inc     TBHP
				;35	ifdef USE_TABRD
				;36	  tabrd mp0
				;37	else
				;38	  tabrdc mp0
0037	1D01	tabrd   MP0
				;39	endif
				;40	  sz mp0
0038	1081	sz      MP0
				;41	  jmp read_data1
0039	283B	jmp     read_data1
				;42	  jmp end_startup_value
003A	2850	jmp     next_table_tentative
				;43	read_data1:
				;44	  inc tblp
				read_data1:
003B	1487	inc     TBLP
				;45	  sz z
003C	3D0A	sz      Z
				;46	  inc tbhp
003D	1489	inc     TBHP
				;47	ifdef USE_TABRD
				;48	  tabrd mp1l
				;49	else
				;50	  tabrdc mp1l
003E	1D03	tabrd   MP1
				;51	endif
				;52	  mov a,tblh
003F	0708	mov     a, TBLH
				;53	  mov mp1h,a
0040	0084	mov     BP, a
				;54	next_data:
				;55	  inc tblp
				next_data:
0041	1487	inc     TBLP
				;56	  sz z
0042	3D0A	sz      Z
				;57	  inc tbhp
0043	1489	inc     TBHP
				;58	ifdef USE_TABRD
				;59	  tabrd acc
				;60	else
				;61	  tabrdc acc
0044	1D05	tabrd   ACC
				;62	endif
				;63	  mov r1,a
0045	0082	mov     __iar1[0], a
				;64	  sdz mp0
0046	1781	sdz     MP0
				;65	  jmp $+2
0047	2849	jmp     L0049
				;66	  jmp next_table
0048	2834	jmp     next_table
				;67	  inc mp1l
				L0049:
0049	1483	inc     MP1
				;68	  mov a,tblh
004A	0708	mov     a, TBLH
				;69	  mov r1,a
004B	0082	mov     __iar1[0], a
				;70	  inc mp1l
004C	1483	inc     MP1
				;71	  sdz mp0
004D	1781	sdz     MP0
				;72	  jmp next_data
004E	2841	jmp     next_data
				;73	  jmp next_table
004F	2834	jmp     next_table
				;74	
				;75	end_startup_value:
				;76	
				;77	; with tentative 0
				;78	;
				;79	begin_startup_tentative:
				;80	next_table_tentative:
				;81	  ;CLR WDT
				;82	  inc tblp
				next_table_tentative:
				begin_startup_tentative:
				end_startup_value:
0050	1487	inc     TBLP
				;83	  sz z
0051	3D0A	sz      Z
				;84	  inc tbhp
0052	1489	inc     TBHP
				;85	ifdef USE_TABRD
				;86	  tabrd mp0
				;87	else
				;88	  tabrdc mp0
0053	1D01	tabrd   MP0
				;89	endif
				;90	  sz mp0
0054	1081	sz      MP0
				;91	  jmp read_data2
0055	2857	jmp     read_data2
				;92	  jmp end_startup_tentative
0056	2862	jmp     startupend1
				;93	read_data2:
				;94	  inc tblp
				read_data2:
0057	1487	inc     TBLP
				;95	  sz z
0058	3D0A	sz      Z
				;96	  inc tbhp
0059	1489	inc     TBHP
				;97	ifdef USE_TABRD
				;98	  tabrd mp1l
				;99	else
				;100	  tabrdc mp1l
005A	1D03	tabrd   MP1
				;101	endif
				;102	  mov a,tblh
005B	0708	mov     a, TBLH
				;103	  mov mp1h,a
005C	0084	mov     BP, a
				;104	next_data_0:
				;105	  clr r1
				next_data_0:
005D	1F02	clr     __iar1[0]
				;106	  inc mp1l  
005E	1483	inc     MP1
				;107	  sdz mp0
005F	1781	sdz     MP0
				;108	  jmp next_data_0
0060	285D	jmp     next_data_0
				;109	  jmp next_table_tentative
0061	2850	jmp     next_table_tentative
				;110	end_startup_tentative:
				;111	
				;112	startupend1:
				;113	ifndef Disable_Bit_Initial
				;114		MOV A,high  bitdatasec1_start
				startupend1:
				end_startup_tentative:
0062	0F00	mov     a, 0H
				;115		MOV mp1h,a
0063	0084	mov     BP, a
				;116		MOV A,offset bitdatasec1_end
0064	0FBD	mov     a, BDH
				;117		mov mp1l,A
0065	0083	mov     MP1, a
				;118		dec mp1l
0066	1583	dec     MP1
				;119		clr z
0067	350A	clr     Z
				;120		sub a,offset bitdatasec1_start
0068	0ABD	sub     a, BDH
				;121		sz z
0069	3D0A	sz      Z
				;122		jmp startupend2
006A	286F	jmp     startupend2
				;123	L0005:
				;124		set r1
				L0005:
006B	1F82	set     __iar1[0]
				;125		dec mp1l
006C	1583	dec     MP1
				;126		sdz  acc
006D	1785	sdz     ACC
				;127		jmp L0005
006E	286B	jmp     L0005
				;128	
				;129	startupend2:
				;130		MOV A,high  bitdatasec0_start
				startupend2:
006F	0F00	mov     a, 0H
				;131		MOV mp1h,a
0070	0084	mov     BP, a
				;132		MOV A,offset bitdatasec0_end
0071	0FBE	mov     a, BEH
				;133		mov mp1l,A
0072	0083	mov     MP1, a
				;134		dec mp1l
0073	1583	dec     MP1
				;135		clr z
0074	350A	clr     Z
				;136		sub a,offset bitdatasec0_start
0075	0ABD	sub     a, BDH
				;137		sz  z
0076	3D0A	sz      Z
				;138		jmp startupend3
0077	287C	jmp     startupend3
				;139	L0006:
				;140		clr r1
				L0006:
0078	1F02	clr     __iar1[0]
				;141		dec mp1l
0079	1583	dec     MP1
				;142		sdz  acc
007A	1785	sdz     ACC
				;143		jmp L0006
007B	2878	jmp     L0006
				;144	startupend3:
				;145	endif
				;146	   
				;147	@ROMDATA_BASE .SECTION com_l 'CODE'  
				;148	startup_value:
				;149	;;linker range the initial value table here
				;150	
				;151	@BITDATASEC1 .SECTION com_l 'DATA'  
				;152	bitdatasec1_start:
				;153	
				;154	@BITDATASEC1 .SECTION com_e 'DATA'  
				;155	bitdatasec1_end:
				;156	
				;157	@BITDATASEC .SECTION com_l 'DATA'  
				;158	bitdatasec0_start:
				;159	
				;160	@BITDATASEC .SECTION com_e 'DATA'  
				;161	bitdatasec0_end:
				;file D:\WORK\Project\Github\etable\code\lib\my_fun.c
				;1	/*
				;2	181206:
				;3	1. modify EE_Write_Byte(): inline assembly, WREN & WE
				;4	2. modify EE_Read_Byte(): inline assembly, REN & RE
				;5	181207:
				;6	1. modify atou()
				;7	*/
				;8	#include "my_func.h"
				;9	
				;10	void Delay(uint16_t count) //1000 => 3ms
				;11	{
				;12	    volatile uint16_t i;
				;13	    for(i=0;i<count;i++)
				;14	    {
				;15	    	FeedWatchDog();
				;16	    }
				;17	}
				;18	
				;19	/* Copy String */
				;20	uint8_t my_strcpy(uint8_t dest[], const char source[])
				;21	{
				;22		int i = 0;
				;23		while (source[i] != '\0')
				;24		{
				;25			dest[i] = (uint8_t)source[i];
				;26			if (i > 16)
				;27				break;
				;28			else
				;29				i++;
				;30			FeedWatchDog();
				;31		}
				;32		dest[i] = '\0';
				;33		return i; // not include '0'
				;34	}
				;35	
				;36	/* Copy String with fixed number*/
				;37	void my_strcpy1(uint8_t num, uint8_t dest[], const char source[])
				;38	{
				_my_strcpy1:
				_my_strcpy1:
007D	40F1	mov     num[0], a
				;39		int i = 0;
				;40		for (i=0 ; i < num ; i++)
007E	5F3F	clr     rb
007F	5F40	clr     rc
0080	2896	jmp     L0096
0093	54BF	inc     rb
0094	3D0A	sz      Z
0095	54C0	inc     rc
				L0096:
0096	4771	mov     a, num[0]
0097	40C1	mov     rd, a
0098	5F42	clr     re
0099	473F	mov     a, rb
009A	4241	sub     a, rd
009B	4740	mov     a, rc
009C	5242	sbc     a, re
009D	1185	swap    ACC
009E	040A	xor     a, STATUS
009F	3D85	sz      ACC.3
00A0	2881	jmp     L0081
00A1	0003	ret
				;41		{
				;42			dest[i] = (uint8_t)source[i];
				L0081:
0081	473F	mov     a, rb
0082	436F	add     a, source[0]
0083	0083	mov     MP1, a
0084	4740	mov     a, rc
0085	5370	adc     a, source[1]
0086	0081	mov     MP0, a
0087	24C1	call    L04C1
0088	40BE	mov     ra, a
0089	473F	mov     a, rb
008A	436D	add     a, dest[0]
008B	0083	mov     MP1, a
008C	4740	mov     a, rc
008D	536E	adc     a, dest[1]
008E	0081	mov     MP0, a
008F	0701	mov     a, MP0
0090	0084	mov     BP, a
0091	473E	mov     a, ra
0092	0082	mov     __iar1[0], a
				;43		}
				;44	}
				;45	
				;46	/* Compare 2 strings */
				;47	uint8_t my_strcmp(uint8_t num, uint8_t dest[], const char source[])
				;48	{
				;49		int i = 0;
				;50		for (i=0 ; i < num ; i++)
				;51		{
				;52			if (dest[i] != (uint8_t)source[i])
				;53				return FALSE;			
				;54		}
				;55		return TRUE;
				;56	}
				;57	
				;58	/* Convert number to Hex String
				;59		1 => '1'  0x0A -> 'A'
				;60	*/
				;61	uint8_t Hex2char(uint8_t num)
				;62	{
				;63		volatile uint8_t u8temp;
				;64		
				;65		u8temp = num & 0x0F;
				;66		if (u8temp <= 9)
				;67		{			
				;68			return u8temp + '0';
				;69		}
				;70		else 
				;71		{
				;72			return (u8temp - 10) + 'A';
				;73		}	
				;74	}
				;75	
				;76	/* Convert Hex char to number 
				;77		'1' -> 1 'A' -> 0x0A
				;78	*/
				;79	uint8_t Char2hex(uint8_t num)
				;80	{
				;81		if ((num >= '0') && (num <= '9'))
				;82		{
				;83			return (num - '0');	
				;84		}
				;85		else if ((num >= 'A') && (num <= 'F'))
				;86		{
				;87			return ((num - 'A') + 10);
				;88		}
				;89		else
				;90			return 0;
				;91	}
				;92	
				;93	/* decimal to string, n=123 , str[2~0] = "123" */
				;94	void utoa(uint16_t n , uint8_t *str)  
				;95	{
				;96		uint8_t i;
				;97		volatile uint16_t temp;
				;98		
				;99		temp = n;
				_utoa:
				_utoa:
00A2	4775	mov     a, n[0]
00A3	40F9	mov     temp[0], a
00A4	4776	mov     a, n[1]
00A5	40FA	mov     temp[1], a
				;100		if (n ==0 )
00A6	4775	mov     a, n[0]
00A7	4576	or      a, n[1]
00A8	390A	snz     Z
00A9	28C7	jmp     _L29
				_L29:
00C7	0F03	mov     a, 3H
00C8	40BE	mov     ra, a
00C9	5F41	clr     rd
				;101		{
				;102			for (i = 0; i < 3; i++)
				;103				str[i] = '0';
00AA	4777	mov     a, str[0]
00AB	0083	mov     MP1, a
00AC	4778	mov     a, str[1]
00AD	0081	mov     MP0, a
00AE	0701	mov     a, MP0
00AF	0084	mov     BP, a
00B0	0F30	mov     a, 30H
00B1	0082	mov     __iar1[0], a
00B2	0F01	mov     a, 1H
00B3	4377	add     a, str[0]
00B4	0083	mov     MP1, a
00B5	0F00	mov     a, 0H
00B6	5378	adc     a, str[1]
00B7	0081	mov     MP0, a
00B8	0701	mov     a, MP0
00B9	0084	mov     BP, a
00BA	0F30	mov     a, 30H
00BB	0082	mov     __iar1[0], a
00BC	0F02	mov     a, 2H
00BD	4377	add     a, str[0]
00BE	0083	mov     MP1, a
00BF	0F00	mov     a, 0H
00C0	5378	adc     a, str[1]
00C1	0081	mov     MP0, a
00C2	0701	mov     a, MP0
00C3	0084	mov     BP, a
00C4	0F30	mov     a, 30H
00C5	0082	mov     __iar1[0], a
00C6	28F9	jmp     _L28
				;104		}
				;105		else
				;106		{
				;107			for (i = 0; i < 3; i++)
00F6	54C1	inc     rd
00F7	57BE	sdz     ra
00F8	28CA	jmp     _L31
				_L28:
00F9	0003	ret
				;108			{
				;109				str[i] = "0123456789"[temp%10];	// str[2]:MSB
				_L31:
00CA	5F73	clr     i
00CB	4779	mov     a, temp[0]
00CC	40ED	mov     level, a
00CD	477A	mov     a, temp[1]
00CE	40EE	mov     addr, a
00CF	0F0A	mov     a, AH
00D0	40EF	mov     addr, a
00D1	5F70	clr     buff
00D2	249B	call    L049B
00D3	4771	mov     a, num
00D4	40BF	mov     rb, a
00D5	4772	mov     a, n
00D6	40C0	mov     rc, a
00D7	0F02	mov     a, 2H
00D8	433F	add     a, rb
00D9	0083	mov     MP1, a
00DA	0F80	mov     a, 80H
00DB	5340	adc     a, rc
00DC	0081	mov     MP0, a
00DD	24C1	call    L04C1
00DE	40BF	mov     rb, a
00DF	4741	mov     a, rd
00E0	4377	add     a, str[0]
00E1	0083	mov     MP1, a
00E2	1F05	clr     ACC
00E3	5378	adc     a, str[1]
00E4	0081	mov     MP0, a
00E5	0701	mov     a, MP0
00E6	0084	mov     BP, a
00E7	473F	mov     a, rb
00E8	0082	mov     __iar1[0], a
				;110				temp /= 10;
00E9	5F73	clr     i
00EA	4779	mov     a, temp[0]
00EB	40ED	mov     level, a
00EC	477A	mov     a, temp[1]
00ED	40EE	mov     addr, a
00EE	0F0A	mov     a, AH
00EF	40EF	mov     addr, a
00F0	5F70	clr     buff
00F1	249B	call    L049B
00F2	476D	mov     a, level
00F3	40F9	mov     temp[0], a
00F4	476E	mov     a, addr
00F5	40FA	mov     temp[1], a
				;111			}	
				;112		}
				;113	}
				;114	
				;115	uint8_t strlen(uint8_t *str)
				;116	{
				;117		uint8_t n = 0;
				;118		while (str[n] != '\0')
				;119		{
				;120			if (n > 32)
				;121				break;
				;122			else
				;123				n++;
				;124			FeedWatchDog();
				;125		}	
				;126		return n;	
				;127	}
				;128	
				;129	
				;130	/* string to decimal,str[3~0] = "1234", n=1234  */
				;131	uint32_t atou(uint8_t *str) 
				;132	{
				;133		uint8_t n = 0, i = 0, j = 0;
				;134		volatile uint32_t sum = 0, u32temp = 0, dig10 = 0;
				;135		
				;136		n= strlen(str);
				;137		
				;138		for (i = 0; i < n; i++)
				;139		{
				;140			u32temp = Char2hex(str[n - 1 - i]);
				;141			dig10 = 1;
				;142			for (j = 0; j < i; j++)
				;143				dig10 *= 10;
				;144			u32temp *= dig10;
				;145			sum += u32temp;
				;146		}
				;147		return sum;
				;148	}
				;149	
				;150	
				;151	uint8_t EE_Write_Byte(uint8_t addr, uint8_t data)  // please add 5ms delay after next write
				;152	{
				_EE_Write_Byte:
				_EE_Write_Byte:
00FA	40BE	mov     ra, a
00FB	40EE	mov     addr[0], a
				;153		uint16_t i = 0xFFFF;
0108	5FBF	set     rb
0109	5FC0	set     rc
				;154		
				;155		_eea = addr;
00FC	473E	mov     a, ra
00FD	009E	mov     EEA, a
				;156		_eed = data;
00FE	476D	mov     a, data[0]
00FF	009F	mov     EED, a
				;157		_mp1 = 0x40; //EEC control register is located at address 40H in Bank 1
0100	0F40	mov     a, 40H
0101	0083	mov     MP1, a
				;158		_bp = 0x01;
0102	0F01	mov     a, 1H
0103	0084	mov     BP, a
				;159		_emi = 0;
0104	340E	clr     EMI
				;160		iar1_3 = 1; iar1_2 = 1;
0105	3182	set     __iar1[0].3
0106	3102	set     __iar1[0].2
				;161		_emi =1;
0107	300E	set     EMI
				;162		while ((_iar1 & 0x04) == 0x04) // check if write cycle finished
				L010A:
010A	3902	snz     __iar1[0].2
010B	2915	jmp     L0115
				;163		//while (iar1_2 == 1)
				;164		{		
				;165			GCC_CLRWDT();
010C	0001	clr     wdt
				;166			i--;
010D	0FFF	mov     a, FFH
010E	43BF	addm    a, rb
010F	0FFF	mov     a, FFH
0110	53C0	adcm    a, rc
				;167			if (i == 0)
0111	473F	mov     a, rb
0112	4540	or      a, rc
0113	390A	snz     Z
0114	290A	jmp     L010A
				;168			{
				;169				break;
				;170			}
				;171		}
				;172		_iar1 = 0;
				L0115:
0115	1F02	clr     __iar1[0]
				;173		_bp = 0;
0116	1F04	clr     BP
				;174		if (i == 0)
0117	0F00	mov     a, 0H
0118	423F	sub     a, rb
0119	40C3	mov     rf, a
011A	0F00	mov     a, 0H
011B	5240	sbc     a, rc
011C	40C4	mov     rg, a
011D	4744	mov     a, rg
011E	45C0	orm     a, rc
011F	4743	mov     a, rf
0120	45BF	orm     a, rb
0121	5840	rla     rc
0122	0E01	and     a, 1H
0123	40BE	mov     ra, a
				;175			return 0;
				;176		else
				;177			return 1;	
				;178	}
0124	473E	mov     a, ra
0125	0003	ret
				;179	
				;180	void EE_Write(uint8_t n, uint8_t addr, uint8_t *buff)
				;181	{
				_EE_Write:
				_EE_Write:
0126	40F2	mov     n[0], a
				;182		uint8_t i;
				;183		for (i = 0; i < n; i++)
0127	5F73	clr     i[0]
				L0128:
0128	4773	mov     a, i[0]
0129	4272	sub     a, n[0]
012A	3C0A	sz      C
012B	293F	jmp     L013F
				L013D:
013D	54F3	inc     i[0]
013E	2928	jmp     L0128
				L013F:
013F	0003	ret
				;184		{
				;185			if (EE_Write_Byte(addr + i, buff[i]) == 0)
012C	4773	mov     a, i[0]
012D	436F	add     a, addr[0]
012E	40BE	mov     ra, a
012F	4773	mov     a, i[0]
0130	4370	add     a, buff[0]
0131	0083	mov     MP1, a
0132	1F05	clr     ACC
0133	5371	adc     a, buff[1]
0134	0081	mov     MP0, a
0135	24C1	call    L04C1
0136	40ED	mov     level, a
0137	473E	mov     a, ra
0138	20FA	call    _EE_Write_Byte
0139	40BE	mov     ra, a
013A	50BE	sz      ra
013B	293D	jmp     L013D
013C	293F	jmp     L013F
				;186				break;	
				;187		}
				;188	}
				;189	
				;190	uint8_t EE_Read_Byte(uint8_t addr)
				;191	{	
				_EE_Read_Byte:
				_EE_Read_Byte:
0140	40BE	mov     ra, a
0141	40ED	mov     addr[0], a
				;192		uint16_t i = 0xFFFF;	
				;193		_eea = addr;
0142	473E	mov     a, ra
0143	009E	mov     EEA, a
				;194		_mp1 = 0x40; //EEC control register is located at address 40H in Bank 1
0144	0F40	mov     a, 40H
0145	0083	mov     MP1, a
				;195		_bp = 0x01;
0146	0F01	mov     a, 1H
0147	0084	mov     BP, a
				;196		_emi = 0;
0148	340E	clr     EMI
				;197		iar1_1 = 1; iar1_0 = 1;
0149	3082	set     __iar1[0].1
014A	3002	set     __iar1[0].0
				;198		_emi =1;
014B	300E	set     EMI
				;199		while ((_iar1 & 0x01) == 0x01) // check if write cycle finished
014C	5FBF	set     rb
014D	5FC0	set     rc
				L014E:
014E	3802	snz     __iar1[0].0
014F	2959	jmp     L0159
				;200		//while (iar1_0 == 1)
				;201		{
				;202			GCC_CLRWDT();	
0150	0001	clr     wdt
0151	0FFF	mov     a, FFH
0152	43BF	addm    a, rb
0153	0FFF	mov     a, FFH
0154	53C0	adcm    a, rc
				;203			i--;
				;204			if (i == 0)
0155	473F	mov     a, rb
0156	4540	or      a, rc
0157	390A	snz     Z
0158	294E	jmp     L014E
				;205				break;		
				;206		}
				;207		_iar1 = 0;
				L0159:
0159	1F02	clr     __iar1[0]
				;208		_bp = 0;
015A	1F04	clr     BP
				;209		return _eed;
015B	071F	mov     a, EED
015C	40BE	mov     ra, a
				;210	}
015D	473E	mov     a, ra
015E	0003	ret
				;211	
				data .SECTION 'DATA'
				iar1 DB DUP (?) ; iar1
				__mp1 DB DUP (?) ; __mp1
				__bp DB DUP (?) ; __bp
				__intc0 DB DUP (?) ; __intc0
				__intc1 DB DUP (?) ; __intc1
				__intc2 DB DUP (?) ; __intc2
				__pa DB DUP (?) ; __pa
				__pac DB DUP (?) ; __pac
				__papu DB DUP (?) ; __papu
				__wdtc DB DUP (?) ; __wdtc
				__tbc DB DUP (?) ; __tbc
				__lvrc DB DUP (?) ; __lvrc
				__eea DB DUP (?) ; __eea
				__eed DB DUP (?) ; __eed
				__pb DB DUP (?) ; __pb
				__pbc DB DUP (?) ; __pbc
				__pbpu DB DUP (?) ; __pbpu
				__cpc DB DUP (?) ; __cpc
				__pc DB DUP (?) ; __pc
				__pcc DB DUP (?) ; __pcc
				__pcpu DB DUP (?) ; __pcpu
				__acerl DB DUP (?) ; __acerl
				__iicc0 DB DUP (?) ; __iicc0
				__iicc1 DB DUP (?) ; __iicc1
				__iicd DB DUP (?) ; __iicd
				__iica DB DUP (?) ; __iica
				__i2ctoc DB DUP (?) ; __i2ctoc
				__sledc0 DB DUP (?) ; __sledc0
				__sledc1 DB DUP (?) ; __sledc1
				ptr_i2c_tx_buff DB DUP (?) ; ptr_i2c_tx_buff
				ptr_i2c_rx_buff DB DUP (?) ; ptr_i2c_rx_buff
				key_stat DB DUP (?) ; key_stat
				height_str DB DUP (?) ; height_str
				height DB 2 DUP (?) ; height
				led_duty DB 2 DUP (?) ; led_duty
				led_period DB 2 DUP (?) ; led_period
				com DB DUP (?) ; com
				cnt DB DUP (?) ; cnt
				led_tmr DB 4 DUP (?) ; led_tmr
				buff_test DB DUP (?) ; buff_test
				buff_i2c_tx DB DUP (?) ; buff_i2c_tx
				buff_i2c_rx DB DUP (?) ; buff_i2c_rx
				ra DB DUP (?)
				rb DB DUP (?)
				rc DB DUP (?)
				rd DB DUP (?)
				re DB DUP (?)
				rf DB DUP (?)
				rg DB DUP (?)
				ra1c DB DUP (?)
				rb1c DB DUP (?)
				rc1c DB DUP (?)
				rd20 DB DUP (?)
				rb20 DB DUP (?)
				rf20 DB DUP (?)
				rg20 DB DUP (?)
				rh20 DB DUP (?)
				ra20 DB DUP (?)
				rc20 DB DUP (?)
				re20 DB DUP (?)
				r11c DB DUP (?)
				r21c DB DUP (?)
				r31c DB DUP (?)
				r41c DB DUP (?)
				r51c DB DUP (?)
				r61c DB DUP (?)
				r71c DB DUP (?)
				r120 DB DUP (?)
				r220 DB DUP (?)
				r320 DB DUP (?)
				r420 DB DUP (?)
				r520 DB DUP (?)
				r620 DB DUP (?)
				r720 DB DUP (?)
				r12c DB DUP (?)
				r22c DB DUP (?)
				r128 DB DUP (?)
				r228 DB DUP (?)
				r328 DB DUP (?)
				r428 DB DUP (?)
				r528 DB DUP (?)
				r628 DB DUP (?)
				r728 DB DUP (?)
				u8temp DB DUP (?) ; u8temp
				sel DB DUP (?) ; sel
				_Led_Scan_2 DB DUP (?)
				level DB DUP (?) ; level
				addr DB DUP (?) ; addr
				addr DB DUP (?) ; addr
				buff DB DUP (?) ; buff
				num DB DUP (?) ; num
				n DB DUP (?) ; n
				i DB DUP (?) ; i
				n DB 2 DUP (?) ; n
				str DB DUP (?) ; str
				temp DB 2 DUP (?) ; temp
				n DB DUP (?) ; n
				i DB DUP (?) ; i
				ee_data DB DUP (?) ; ee_data
				ee_addr DB DUP (?) ; ee_addr
				b_ee_data_ready DB DUP (?) ; b_ee_data_ready
